SPARTA (20 Jan 2025)
Running on 16 MPI task(s)
# SETUP --------------------------------------------------------------------------------------

shell "bash -c 'rm -f dumps/*.dat'"

shell "mkdir -p dumps"

units           si
seed            11111
dimension       3

# outflow in +x, periodic y,z. will inject at xlo (x=0)
boundary        o p p

# domain size (m)
variable        xmin equal -1.1
variable        xmax equal 1.1
variable        ymin equal -1.1
variable 	    ymax equal 1.1
variable	    zmin equal -1.1
variable	    zmax equal 1.1

variable	    Lx equal ${xmax}-${xmin}
variable	    Lx equal 1.1-${xmin}
variable	    Lx equal 1.1--1.1
variable        Ly equal ${ymax}-${ymin}
variable        Ly equal 1.1-${ymin}
variable        Ly equal 1.1--1.1
variable        Lz equal ${zmax}-${zmin}
variable        Lz equal 1.1-${zmin}
variable        Lz equal 1.1--1.1

create_box      ${xmin} ${xmax} ${ymin} ${ymax} ${zmin} ${zmax}
create_box      -1.1 ${xmax} ${ymin} ${ymax} ${zmin} ${zmax}
create_box      -1.1 1.1 ${ymin} ${ymax} ${zmin} ${zmax}
create_box      -1.1 1.1 -1.1 ${ymax} ${zmin} ${zmax}
create_box      -1.1 1.1 -1.1 1.1 ${zmin} ${zmax}
create_box      -1.1 1.1 -1.1 1.1 -1.1 ${zmax}
create_box      -1.1 1.1 -1.1 1.1 -1.1 1.1
Created orthogonal box = (-1.1 -1.1 -1.1) to (1.1 1.1 1.1)

# Load atmospheric data from NRLMSIS (run: python3 tools/load_atm_data.py)
variable        rho  file data/rho.dat
variable        nrho file data/nrho.dat
variable        T    file data/T.dat
variable        vx   file data/vx.dat

print "Loaded NRLMSIS data: rho=${rho} nrho=${nrho} T=${T} vx=${vx}"
Loaded NRLMSIS data: rho=7.523213913345e-06 nrho=1.564147e+20 T=190.251112 vx=7853.3

variable 	kB equal 1.380649e-23  # J/K
variable 	d equal 3.7e-10  # m
variable 	R equal 287.05 # (J / kg*K)
variable 	lambda equal ${kB}*${T}/(sqrt(2.0)*PI*${d}*${d}*${rho}*${R}) # m
variable 	lambda equal 1.380649e-23*${T}/(sqrt(2.0)*PI*${d}*${d}*${rho}*${R}) 
variable 	lambda equal 1.380649e-23*190.251112/(sqrt(2.0)*PI*${d}*${d}*${rho}*${R}) 
variable 	lambda equal 1.380649e-23*190.251112/(sqrt(2.0)*PI*3.7e-10*${d}*${rho}*${R}) 
variable 	lambda equal 1.380649e-23*190.251112/(sqrt(2.0)*PI*3.7e-10*3.7e-10*${rho}*${R}) 
variable 	lambda equal 1.380649e-23*190.251112/(sqrt(2.0)*PI*3.7e-10*3.7e-10*7.523213913345e-06*${R}) 
variable 	lambda equal 1.380649e-23*190.251112/(sqrt(2.0)*PI*3.7e-10*3.7e-10*7.523213913345e-06*287.05) 
variable	vbar equal sqrt(8*${kB}*${T}/(PI*${rho}/${nrho})) # m/s
variable	vbar equal sqrt(8*1.380649e-23*${T}/(PI*${rho}/${nrho})) 
variable	vbar equal sqrt(8*1.380649e-23*190.251112/(PI*${rho}/${nrho})) 
variable	vbar equal sqrt(8*1.380649e-23*190.251112/(PI*7.523213913345e-06/${nrho})) 
variable	vbar equal sqrt(8*1.380649e-23*190.251112/(PI*7.523213913345e-06/1.564147e+20)) 

print "MEAN FREE PATH = ${lambda} m"
MEAN FREE PATH = 1.99977532814667 m
print "MEAN MOLEC VEL = ${vbar} m/s"
MEAN MOLEC VEL = 372.917168581365 m/s

# grid resolution

variable	dx equal ${lambda}/3 # m
variable	dx equal 1.99977532814667/3 
variable	mct equal ${lambda}/${vbar} # s
variable	mct equal 1.99977532814667/${vbar} 
variable	mct equal 1.99977532814667/372.917168581365 
variable	mtt equal ${dx}/${vbar} # s
variable	mtt equal 0.66659177604889/${vbar} 
variable	mtt equal 0.66659177604889/372.917168581365 
variable	dt equal ((${mct}<${mtt})*${mct}+(${mct}>=${mtt})*${mtt})/3.0 # min(${mct},${mtt})/3.0
variable	dt equal ((0.00536251880210859<${mtt})*${mct}+(${mct}>=${mtt})*${mtt})/3.0 
variable	dt equal ((0.00536251880210859<0.00178750626736953)*${mct}+(${mct}>=${mtt})*${mtt})/3.0 
variable	dt equal ((0.00536251880210859<0.00178750626736953)*0.00536251880210859+(${mct}>=${mtt})*${mtt})/3.0 
variable	dt equal ((0.00536251880210859<0.00178750626736953)*0.00536251880210859+(0.00536251880210859>=${mtt})*${mtt})/3.0 
variable	dt equal ((0.00536251880210859<0.00178750626736953)*0.00536251880210859+(0.00536251880210859>=0.00178750626736953)*${mtt})/3.0 
variable	dt equal ((0.00536251880210859<0.00178750626736953)*0.00536251880210859+(0.00536251880210859>=0.00178750626736953)*0.00178750626736953)/3.0 

print "CELL SIZE MUST BE LESS THAN ${dx} m"
CELL SIZE MUST BE LESS THAN 0.66659177604889 m
print "MEAN COLL TIME = ${mct} s"
MEAN COLL TIME = 0.00536251880210859 s
print "MEAN TRANSIT TIME = ${mtt} s"
MEAN TRANSIT TIME = 0.00178750626736953 s
print "TIMESTEP MUST BE < ${dt} s" # timestep set at end of script
TIMESTEP MUST BE < 0.00059583542245651 s

create_grid	150 100 50
WARNING: Per-processor grid cell memory will be large because global gridcut < 0.0 (../grid.cpp:499)
Created 750000 child grid cells
  CPU time = 1.21878 secs
  create/ghost percent = 1.99567 98.0043
balance_grid    rcb part
WARNING: Per-processor grid cell memory will be large because global gridcut < 0.0 (../grid.cpp:499)
Balance grid migrated 702941 cells
  CPU time = 1.30749 secs
  reassign/sort/migrate/ghost percent = 9.90174 0.284163 9.07606 80.738

variable	diag_freq   equal 100 # dump diagnostics every _ timesteps
variable 	tstep       equal 1.0e-7 # choose small timestep << cell flight time; start 1e-7 s

# SURFACE GEOMETRY ----------------------------------------------------------------------------

read_surf	surf/thin_plate.surf  group ampt        # create surface group "ampt"
  12 triangles
  0 0.01 xlo xhi
  -0.1 0.1 ylo yhi
  -0.1 0.1 zlo zhi
  0.01 min triangle edge length
  0.001 min triangle area
  120 = cells with surfs
  340 = total surfs in all grid cells
  8 = max surfs in one grid cell
  0.227273 = min surf-size/cell-size ratio
  120 0 = cells overlapping surfs, overlap cells with unmarked corner pts
WARNING: Per-processor grid cell memory will be large because global gridcut < 0.0 (../grid.cpp:499)
  749880 0 120 = cells outside/inside/overlapping surfs
  120 = surf cells with 1,2,etc splits
  10.6476 10.6476 = cell-wise and global flow volume
  CPU time = 1.31243 secs
  read/check/sort/surf2grid/ghost/inout/particle percent = 0.574865 0.231726 2.26389 4.18188 92.7476 10.487 1.15762
  surf2grid time = 0.0548841 secs
  map/comm1/comm2/comm3/comm4/split percent = 28.6645 0 0 0 0 32.8126
group       ampt_xnorm surf id 1:4              # front/back
0 = initial surface count in group ampt_xnorm
4 = final surface count in group ampt_xnorm
group       ampt_yznorm surf id 5:12             # walls
0 = initial surface count in group ampt_yznorm
8 = final surface count in group ampt_yznorm

read_surf	surf/xlo_bdy.surf  group xlo_bdy transparent
  2 triangles
  -1 -1 xlo xhi
  -1.1 1.1 ylo yhi
  -1.1 1.1 zlo zhi
  2.2 min triangle edge length
  2.42 min triangle area
  5120 = cells with surfs
  5534 = total surfs in all grid cells
  8 = max surfs in one grid cell
  0.227273 = min surf-size/cell-size ratio
  120 0 = cells overlapping surfs, overlap cells with unmarked corner pts
WARNING: Per-processor grid cell memory will be large because global gridcut < 0.0 (../grid.cpp:499)
  749880 0 120 = cells outside/inside/overlapping surfs
  120 = surf cells with 1,2,etc splits
  10.6476 10.6476 = cell-wise and global flow volume
  CPU time = 1.45394 secs
  read/check/sort/surf2grid/ghost/inout/particle percent = 1.85468 2.26636 2.35862 2.17265 91.3477 4.11517 0.00673763
  surf2grid time = 0.031589 secs
  map/comm1/comm2/comm3/comm4/split percent = 41.2832 0 0 0 0 50.6176
read_surf	surf/xhi_bdy.surf  group xhi_bdy transparent
  2 triangles
  0.7 0.7 xlo xhi
  -1.1 1.1 ylo yhi
  -1.1 1.1 zlo zhi
  2.2 min triangle edge length
  2.42 min triangle area
  120 0 = cells overlapping surfs, overlap cells with unmarked corner pts
WARNING: Per-processor grid cell memory will be large because global gridcut < 0.0 (../grid.cpp:499)
  749880 0 120 = cells outside/inside/overlapping surfs
  120 = surf cells with 1,2,etc splits
  10.6476 10.6476 = cell-wise and global flow volume
  CPU time = 1.31429 secs
  read/check/sort/surf2grid/ghost/inout/particle percent = 0.0131607 0.021739 1.94713 6.29878 91.7192 4.07464 0.0145971
  surf2grid time = 0.0827843 secs
  map/comm1/comm2/comm3/comm4/split percent = 19.8123 9.55825 18.5903 10.7821 5.2362 10.1127



# SPECIES AND MIXTURE -------------------------------------------------------------------------

# use local species file
species         species/air.species N2 O2

# define inflow gas mixture named atm
mixture 	atm N2 frac 0.79
mixture		atm O2 frac 0.21
mixture     	atm nrho ${nrho} vstream ${vx} 0.0 0.0 temp ${T}
mixture     	atm nrho 1.564147e+20 vstream ${vx} 0.0 0.0 temp ${T}
mixture     	atm nrho 1.564147e+20 vstream 7853.3 0.0 0.0 temp ${T}
mixture     	atm nrho 1.564147e+20 vstream 7853.3 0.0 0.0 temp 190.251112

# particle weighting: set target of 2e5 sim particles, calculate weighting factor
variable        Ns_target equal 2000000.0
variable        Vol       equal ${Lx}*${Ly}*${Lz}
variable        Vol       equal 2.2*${Ly}*${Lz}
variable        Vol       equal 2.2*2.2*${Lz}
variable        Vol       equal 2.2*2.2*2.2
variable        fnum      equal ${nrho}*${Vol}/${Ns_target}
variable        fnum      equal 1.564147e+20*${Vol}/${Ns_target}
variable        fnum      equal 1.564147e+20*10.648/${Ns_target}
variable        fnum      equal 1.564147e+20*10.648/2000000
global          fnum ${fnum} # global bc will be queried by each new particle
global          fnum 832751862800000 

variable	parts_per equal ${nrho}/${Ns_target}
variable	parts_per equal 1.564147e+20/${Ns_target}
variable	parts_per equal 1.564147e+20/2000000
print "particles per particle = ${parts_per}"
particles per particle = 78207350000000

# global useful for stat query later
global          nrho ${nrho}
global          nrho 1.564147e+20

# create an initial fill (n 0 -> auto compute # of particles from fnum and nrho)
create_particles	atm n 0
Created 1999924 particles
  CPU time = 0.0685741 secs

# continuous inflow; inject gas from xlo every step (fix -> run each time step, ID: "in")
fix		in emit/face atm xlo

# SURFACE COLLISIONS --------------------------------------------------------------------------

                # compute ID, type, surf group, mixture, property (energy flux on surface)
compute         compute_qwall surf ampt atm etot # etot = kinetic + internal energy. W/m^2 *multi-column array for all surface groups

                # runningâ€‘average every step so flux is never exactly zero (exponential decay)
fix             flux ave/surf ampt 1 1 1 c_compute_qwall[1] ave running  # running mean, updates each step
fix             fix_Tsurf surf/temp ampt 1 f_flux 300.0 0.9 Tsurf  # Stefan-Boltzmann

# Define collision models
surf_collide 	wall_diffuse diffuse s_Tsurf 0.9   # diffuse model for front/back, random dir, use local facet temp, acc
surf_collide    wall_specular specular noslip      # specular model for walls
# Apply to respective surface groups
surf_modify 	ampt_xnorm collide wall_diffuse    # attach model to facets
surf_modify 	ampt_yznorm collide wall_specular

surf_collide    trans transparent                  # define transparent collision model for boundary surfaces
surf_modify     xlo_bdy collide trans              # attach transparent model to xlo_bdy
surf_modify     xhi_bdy collide trans              # attach transparent model to xhi_bdy

# DIAGNOSTICS ---------------------------------------------------------------------------------

                # ID, data type, mixture, every _ steps, filename, columns (particle data)
dump            dump_part particle atm ${diag_freq} dumps/part.*.dat id type x y z vx vy vz
dump            dump_part particle atm 100 dumps/part.*.dat id type x y z vx vy vz

                # ID, type, region, mixture, property (gas temperature per grid cell)
compute         compute_Tgrid grid all atm temp # *per-grid array
                # ID, data type, region, every _ steps, filename, columns (cell coords and gas temperature)
dump 		dump_grid grid all ${diag_freq} dumps/grid.*.dat id xlo ylo zlo xc yc zc c_compute_Tgrid[*] # compute for all columns (gases) in array
dump 		dump_grid grid all 100 dumps/grid.*.dat id xlo ylo zlo xc yc zc c_compute_Tgrid[*] 

		# ID, data type, region, every _ steps, filename, columns (facet id, triangle vertices, surface temperature)
dump    	dump_surf surf ampt ${diag_freq} dumps/surf.*.dat id v1x v1y v1z v2x v2y v2z v3x v3y v3z f_flux[*] s_Tsurf
dump    	dump_surf surf ampt 100 dumps/surf.*.dat id v1x v1y v1z v2x v2y v2z v3x v3y v3z f_flux[*] s_Tsurf

# DRAG CALC (short for caclulator) ------------------------
# boundary method: use mass flux and kinetic energy flux through transparent surface.
                    # these can be used to find pressure in front and behind object which gives F_drag

compute         xlo_flux surf xlo_bdy atm mflux ke nflux                                # mflux = mass flux, ke = kinetic energy flux, nflux = num flux
compute         xlo_mflux_avg reduce ave c_xlo_flux[1]                                  # average mass flux
compute         xlo_ke_avg reduce ave c_xlo_flux[2]                                     # average KE flux
compute         xlo_nflux_avg reduce ave c_xlo_flux[3]                                  # average num flux
fix             xlo_out ave/time 1 1 100 c_xlo_mflux_avg c_xlo_ke_avg c_xlo_nflux_avg ave running file dumps/xlo_flux.dat

compute         xhi_flux surf xhi_bdy atm mflux ke nflux
compute         xhi_mflux_avg reduce ave c_xhi_flux[1]
compute         xhi_ke_avg reduce ave c_xhi_flux[2]
compute         xhi_nflux_avg reduce ave c_xhi_flux[3]
fix             xhi_out ave/time 1 1 100 c_xhi_mflux_avg c_xhi_ke_avg c_xhi_nflux_avg ave running file dumps/xhi_flux.dat


# sum of surface forces (direct):
                # compute per-surface-element force components (fx,fy,fz) for all ampt surfaces
compute         surfF surf ampt atm fx fy fz
                # time-average per-surf forces (running mean)
fix             surfavg ave/surf ampt 1 1 1 c_surfF[*] ave running
                # reduce (sum) per-surf averaged fx -> global total drag
compute         drag reduce sum f_surfavg[1]

# compute forces for x-normal surfaces (ram drag)
compute         surfF_xnorm surf ampt_xnorm atm fx fy fz
fix             surfavg_xnorm ave/surf ampt_xnorm 1 1 1 c_surfF_xnorm[*] ave running
compute         drag_xnorm reduce sum f_surfavg_xnorm[1]

# compute forces for y/z-normal surfaces (skin friction)
compute         surfF_walls surf ampt_yznorm atm fx fy fz
fix             surfavg_walls ave/surf ampt_yznorm 1 1 1 c_surfF_walls[*] ave running
compute         drag_walls reduce sum f_surfavg_walls[1]

# write drag components (timestep, total_drag, ram_drag, skin_friction) to file
fix             dragout ave/time 1 1 100 c_drag c_drag_xnorm c_drag_walls file dumps/direct_drag.dat mode scalar

# ----------------------------------------------------------

# cell-averaged (streaming+thermal) temperature
compute         Tbox temp # define a compute Tbox that calculates domain everaged temp
stats           ${diag_freq} # print diagnostics every _ timesteps
stats           100 
stats_style     step cpu np nattempt ncoll c_Tbox c_drag c_drag_xnorm c_drag_walls # print timestep, runtime, particles, collision stats, avg temp, drag components

timestep        ${tstep}
timestep        1e-07
collide		    vss atm vss/air.vss # variable soft sphere model
run             2000
Memory usage per proc in Mbytes:
  particles (ave,min,max) = 13.5 13.5 13.5
  grid      (ave,min,max) = 89.3644 89.3644 89.3644
  surf      (ave,min,max) = 0.00201416 0.00201416 0.00201416
  total     (ave,min,max) = 103.582 103.582 103.582
Step CPU Np Natt Ncoll c_Tbox c_drag c_drag_xnorm c_drag_walls 
       0            0  1999924        0        0    71494.825            0            0            0 
     100    6.5704645  2000327     1302     1084    71475.468     20.48796     20.48796            0 
     200    13.517908  2000109     5873     4811     71451.12     21.81742    21.520616   0.29680397 
     300    20.672581  2000136     5669     4467     71426.46     22.03634    21.662305    0.3740358 
     400    27.822682  2000390     5633     4373    71404.918    21.775426    21.418322   0.35710399 
     500    35.019063  2000271     6044     4587    71382.352    21.652955    21.233954    0.4190014 
     600    42.516907  1999691     6157     4610    71362.632    21.593456    21.154077   0.43937853 
     700    49.828921  1999550     6320     4686    71339.872    21.370764    20.929571   0.44119296 
     800    58.365812  1999380     6448     4719    71317.303    21.260394    20.796274   0.46412038 
     900    66.009166  1999627     6569     4719    71296.921    21.172519    20.698829   0.47369053 
    1000    73.164347  1999551     6881     4922    71280.443    20.982384    20.507254   0.47512928 
    1100    80.501529  1999604     6740     4724    71262.458    20.752893    20.283026   0.46986721 
    1200    87.737591  1999633     6903     4885    71242.997    20.665432    20.207504   0.45792776 
    1300    94.862348  1999529     6791     4745    71223.072    20.607863    20.161549   0.44631344 
    1400    102.10356  1999687     7022     5020    71202.273    20.571161    20.126354   0.44480669 
    1500    109.38535  2000093     7120     4965    71183.683      20.4062    19.953698    0.4525018 
    1600    116.83165  2000647     7244     5037    71161.372    20.348327    19.882969   0.46535784 
    1700     125.0954  2001983     7471     5267    71138.875    20.304848    19.826261    0.4785872 
    1800    132.80971  2002364     7425     5150    71112.758    20.227165    19.745274   0.48189083 
    1900    140.27543  2003947     7630     5204    71086.816    20.200005     19.71528   0.48472535 
    2000    147.44553  2005159     7572     5208    71061.943    20.179671    19.696876    0.4827954 
Loop time of 147.446 on 16 procs for 2000 steps with 2005159 particles

MPI task timing breakdown:
Section |  min time  |  avg time  |  max time  |%varavg| %total
---------------------------------------------------------------
Move    | 49.073     | 51.508     | 54.251     |  18.4 | 34.93
Coll    | 7.7587     | 8.431      | 8.8922     |  10.8 |  5.72
Sort    | 37.243     | 38.549     | 40.12      |  13.2 | 26.14
Comm    | 7.2404     | 9.8583     | 11.987     |  39.6 |  6.69
Modify  | 18.196     | 19.806     | 20.83      |  14.7 | 13.43
Output  | 19.272     | 19.288     | 19.294     |   0.1 | 13.08
Other   |            | 0.005076   |            |       |  0.00

Particle moves    = 4002344321 (4B)
Cells touched     = 4219813451 (4.22B)
Particle comms    = 4456468 (4.46M)
Boundary collides = 0 (0K)
Boundary exits    = 1422134 (1.42M)
SurfColl checks   = 69011662 (69M)
SurfColl occurs   = 2872864 (2.87M)
Surf reactions    = 0 (0K)
Collide attempts  = 12595265 (12.6M)
Collide occurs    = 9144925 (9.14M)
Reactions         = 0 (0K)
Particles stuck   = 0
Axisymm bad moves = 0

Particle-moves/CPUsec/proc: 1.69653e+06
Particle-moves/step: 2.00117e+06
Cell-touches/particle/step: 1.05434
Particle comm iterations/step: 1
Particle fraction communicated: 0.00111346
Particle fraction colliding with boundary: 0
Particle fraction exiting boundary: 0.000355325
Surface-checks/particle/step: 0.0172428
Surface-collisions/particle/step: 0.000717795
Surf-reactions/particle/step: 0
Collision-attempts/particle/step: 0.00314697
Collisions/particle/step: 0.00228489
Reactions/particle/step: 0

Particles: 125322 ave 126563 max 123680 min
Histogram: 1 0 0 1 6 3 1 1 0 3
Cells:      46875 ave 46875 max 46875 min
Histogram: 16 0 0 0 0 0 0 0 0 0
GhostCell: 703125 ave 703125 max 703125 min
Histogram: 16 0 0 0 0 0 0 0 0 0
EmptyCell: 0 ave 0 max 0 min
Histogram: 16 0 0 0 0 0 0 0 0 0
Surfs:    16 ave 16 max 16 min
Histogram: 16 0 0 0 0 0 0 0 0 0
GhostSurf: 0 ave 0 max 0 min
Histogram: 16 0 0 0 0 0 0 0 0 0

shell "rm -f data/rho.dat data/nrho.dat data/T.dat data/vx.dat"
