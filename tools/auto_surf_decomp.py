#!/usr/bin/env python3
import numpy as np
import sys

def read_surf_file(filepath):
    with open(filepath, 'r') as f:
        lines = f.readlines()
    
    points = []
    triangles = []
    reading_points = False
    reading_triangles = False
    
    for line in lines:
        line = line.strip()
        if not line or line.startswith('#'):
            continue
            
        if 'Points' in line:
            reading_points = True
            reading_triangles = False
            continue
        elif 'Triangles' in line:
            reading_points = False
            reading_triangles = True
            continue
            
        if reading_points:
            parts = line.split()
            if len(parts) == 4:  # point_id x y z
                points.append([float(parts[1]), float(parts[2]), float(parts[3])])
        elif reading_triangles:
            parts = line.split()
            if len(parts) >= 4:  # tri_id p1 p2 p3
                triangles.append([int(parts[1])-1, int(parts[2])-1, int(parts[3])-1])  # convert to 0-indexed
    
    return np.array(points), np.array(triangles)

def compute_triangle_normal(p1, p2, p3):
    """Compute normal vector for a triangle using cross product."""
    v1 = p2 - p1
    v2 = p3 - p1
    normal = np.cross(v1, v2)
    # normalize
    norm = np.linalg.norm(normal)
    if norm > 0:
        normal = normal / norm
    return normal

def analyze_surface(filepath):
    """Analyze surface and classify triangles by orientation."""
    points, triangles = read_surf_file(filepath)
    
    print(f"Loaded {len(points)} points and {len(triangles)} triangles\n")
    
    lateral_tris = []  # normal perpendicular to x-axis (nx ~ 0)
    ram_tris = []      # normal pointing in -x direction (nx < 0, ny ~ 0, nz ~ 0)
    diffuse_tris = []  # all other triangles not classified above
    
    tolerance = 0.1  # tolerance for "approximately zero" or "approximately parallel"
    
    classified = set()  # track which triangles have been classified
    
    for i, tri in enumerate(triangles):
        p1, p2, p3 = points[tri[0]], points[tri[1]], points[tri[2]]
        normal = compute_triangle_normal(p1, p2, p3)
        
        # lateral surfaces: normal perpendicular to x-axis 
        if abs(normal[0]) < tolerance: # (nx < 0.1)
            lateral_tris.append((i+1, normal, tri))
            classified.add(i+1)
        
        # ram surfaces: normal pointing in -x direction
        elif normal[0] < -0.9 and abs(normal[1]) < tolerance and abs(normal[2]) < tolerance: # (nx < -0.9 and ny, nz < 0)
            ram_tris.append((i+1, normal, tri))
            classified.add(i+1)
    
    # Collect all remaining unclassified triangles as diffuse
    for i, tri in enumerate(triangles):
        if (i+1) not in classified:
            p1, p2, p3 = points[tri[0]], points[tri[1]], points[tri[2]]
            normal = compute_triangle_normal(p1, p2, p3)
            diffuse_tris.append((i+1, normal, tri))
    
    print(f"Lateral surfaces (normal ⊥ x-axis, {len(lateral_tris)} triangles):")
    print("_" * 70)
    for tri_id, normal, tri_pts in lateral_tris:
        print(f"Triangle {tri_id}: points {tri_pts+1}, normal = [{normal[0]:7.4f}, {normal[1]:7.4f}, {normal[2]:7.4f}]")
    
    print(f"\n\nRam surfaces (normal ∥ -x direction, {len(ram_tris)} triangles):")
    print("_" * 70)
    for tri_id, normal, tri_pts in ram_tris:
        print(f"Triangle {tri_id}: points {tri_pts+1}, normal = [{normal[0]:7.4f}, {normal[1]:7.4f}, {normal[2]:7.4f}]")
    
    print(f"\n\nDiffuse surfaces (all remaining triangles, {len(diffuse_tris)} triangles):")
    print("_" * 70)
    for tri_id, normal, tri_pts in diffuse_tris:
        print(f"Triangle {tri_id}: points {tri_pts+1}, normal = [{normal[0]:7.4f}, {normal[1]:7.4f}, {normal[2]:7.4f}]")
    
    print(f"\n\nSUMMARY:")
    print(f"  Total triangles: {len(triangles)}")
    print(f"  Lateral surfaces: {len(lateral_tris)}")
    print(f"  Ram surfaces: {len(ram_tris)}")
    print(f"  Diffuse surfaces: {len(diffuse_tris)}")
    print(f"  Unclassified: {len(triangles) - len(lateral_tris) - len(ram_tris) - len(diffuse_tris)}")
    
    # generate output file
    import os
    base_name = os.path.basename(filepath)
    name_without_ext = os.path.splitext(base_name)[0]
    output_file = f"surf/{name_without_ext}.sparta"
    
    with open(output_file, 'w') as f:
        f.write(f"# Auto-generated surface groups for {base_name}\n")
        f.write(f"# Generated by auto_surf_decomp.py\n\n")
        
        # Write ram surface group
        ram_ids = [str(tri_id) for tri_id, _, _ in ram_tris]
        if ram_ids:
            ids_str = " ".join(ram_ids)
            f.write(f"group           ampt_xnorm surf id {ids_str}              # ram surfaces\n")
        else:
            f.write(f"# No ram surfaces found\n")
        
        # Write lateral surface group
        lateral_ids = [str(tri_id) for tri_id, _, _ in lateral_tris]
        if lateral_ids:
            ids_str = " ".join(lateral_ids)
            f.write(f"group           ampt_yznorm surf id {ids_str}             # lateral surfaces\n")
        else:
            f.write(f"# No lateral surfaces found\n")
        
        # Write diffuse surface group (all remaining triangles)
        diffuse_ids = [str(tri_id) for tri_id, _, _ in diffuse_tris]
        if diffuse_ids:
            ids_str = " ".join(diffuse_ids)
            f.write(f"group           ampt_diffuse surf id {ids_str}            # diffuse surfaces\n")
        else:
            f.write(f"# No diffuse surfaces found\n")
    
    print(f"\n\nGenerated surface groups file: {output_file}")
    return output_file

if __name__ == "__main__":
    if len(sys.argv) > 1:
        surf_file = sys.argv[1]
    else:
        surf_file = "surf/AMPT_sat_no_inlet.surf"
    
    analyze_surface(surf_file)
